day 2:

problem 1: rank scores


SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS 'rank'
FROM Scores;



SELECT s1.score , (SELECT COUNT(DISTINCT s2.score) FROM Scores s2 WHERE s2.score >= s1.score) AS 'rank'
FROM Scores s1
ORDER BY s1.score DESC



SELECT s1. score, COUNT(DISTINCT s2.score) AS 'rank'
FROM Scores s1 JOIN Scores s2 ON s1.score <= s2.score 
GROUP BY s1.id , s1.score 
ORDER BY s1.score DESC



problem 2 :  exchange seats:


SELECT
    CASE
        WHEN id = (select (max(id)) from seat) AND id % 2 != 0 THEN id
        WHEN id % 2 !=0 THEN id+1
        ELSE id -1
    END as id , student 
FROM seat 
ORDER BY id 




SELECT s1.id, COALESCE (s2.student , s1.student) AS student 
FROM Seat s1 LEFT JOIN Seat s2 ON (s1.id + 1)^1-1 = s2.id 
ORDER BY s1.id 





PROBLEM 4: TREE NODE

SELECT id ,
CASE
    WHEN p_id IS null THEN 'Root'
    WHEN id IN (SELECT p_id FROM Tree) THEN 'Inner'
    ELSE 'Leaf'
END AS type
FROM Tree;



SELECT id, 'Root' AS type
FROM Tree
WHERE p_id IS NULL

UNION

SELECT id, 'Leaf' AS type
FROM Tree 
WHERE id NOT IN(SELECT DISTINCT p_id FROM tree WHERE p_id IS NOT NULL) AND p_id IS NOT NULL

UNION

SELECT id, 'Inner' AS type
FROM Tree 
WHERE id in(SELECT DISTINCT p_id FROM tree WHERE p_id IS NOT NULL) AND p_id IS NOT NULL





PROBLEM 4:  DEPARTMENT TOP 3 SALARIES


SELECT department , employee , salary
FROM (
    SELECT 
        d.name AS department, 
        e.name AS employee, 
        e.salary AS salary, 
        DENSE_RANK()() OVER (PARTITION BY d.id ORDER BY e.salary DESC ) AS rnk
    FROM Employee e 
    JOIN Department d 
    ON e.departmentId = d.id) AS ra_nk
WHERE rnk <= 3